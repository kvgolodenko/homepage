/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule writeRelayGeneratedFile
 * 
 * @format
 */

'use strict';

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _extends3 = _interopRequireDefault(require('babel-runtime/helpers/extends'));

var _stringify2 = _interopRequireDefault(require('babel-runtime/core-js/json/stringify'));

let writeRelayGeneratedFile = (() => {
  var _ref2 = (0, _asyncToGenerator3.default)(function* (codegenDir, generatedNode, buildCommand, flowText, persistQuery, platform, relayRuntimeModule) {
    var moduleName = generatedNode.name + '.graphql';
    var platformName = platform ? moduleName + '.' + platform : moduleName;
    var filename = platformName + '.js';
    var flowTypeName = generatedNode.kind === 'Batch' ? 'ConcreteBatch' : 'ConcreteFragment';

    var text = null;
    var hash = null;
    if (generatedNode.kind === 'Batch') {
      text = generatedNode.text;
      require('fbjs/lib/invariant')(text, 'codegen-runner: Expected query to have text before persisting.');
      var oldContent = codegenDir.read(filename);
      // Hash the concrete node including the query text.
      hash = md5((0, _stringify2['default'])(generatedNode) + (persistQuery ? 'persisted' : '') + buildCommand + 'cache-breaker-3');
      if (hash === extractHash(oldContent)) {
        codegenDir.markUnchanged(filename);
        return null;
      }
      if (codegenDir.onlyValidate) {
        codegenDir.markUpdated(filename);
        return null;
      }
      if (persistQuery) {
        generatedNode = (0, _extends3['default'])({}, generatedNode, {
          text: null,
          id: yield persistQuery(text)
        });
      }
    }

    var moduleText = generateModule({
      buildCommand: buildCommand,
      moduleName: moduleName,
      documentType: flowTypeName,
      docText: text,
      flowText: flowText,
      hash: hash,
      concreteText: require('./prettyStringify')(generatedNode),
      relayRuntimeModule: relayRuntimeModule
    });

    codegenDir.writeFile(filename, moduleText);
    return generatedNode;
  });

  return function writeRelayGeneratedFile(_x, _x2, _x3, _x4, _x5, _x6, _x7) {
    return _ref2.apply(this, arguments);
  };
})();

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function extractHash(text) {
  if (!text) {
    return null;
  }
  if (/<<<<<|>>>>>/.test(text)) {
    // looks like a merge conflict
    return null;
  }
  var match = text.match(/^ \* @relayHash (\w{32})$/m);
  return match && match[1];
}

/**
 * Generate a module for the given document name/text.
 */
function generateModule(_ref) {
  var buildCommand = _ref.buildCommand,
      moduleName = _ref.moduleName,
      documentType = _ref.documentType,
      docText = _ref.docText,
      concreteText = _ref.concreteText,
      flowText = _ref.flowText,
      hash = _ref.hash,
      relayRuntimeModule = _ref.relayRuntimeModule;

  var objectName = documentType === 'ConcreteBatch' ? 'batch' : 'fragment';
  var docTextComment = docText ? '\n/*\n' + docText.trim() + '\n*/\n' : '';
  var hashText = hash ? '\n * @relayHash ' + hash : '';
  var source = '/**\n * This file was generated by:\n *   ' + buildCommand + '\n *\n * ' + '@' + 'providesModule ' + moduleName + '\n * ' + require('signedsource').getSigningToken() + hashText + '\n * ' + '@' + 'flow\n * ' + '@' + 'nogrep\n */\n\n/* eslint-disable */\n\n\'use strict\';\n\n/*::\nimport type {' + documentType + '} from \'' + relayRuntimeModule + '\';\n' + (flowText || '') + '\n*/\n\n' + docTextComment + '\nconst ' + objectName + ' /*: ' + documentType + '*/ = ' + concreteText + ';\n\nmodule.exports = ' + objectName + ';\n';
  return require('signedsource').signFile(source);
}

function md5(text) {
  return require('crypto').createHash('md5').update(text).digest('hex');
}

module.exports = writeRelayGeneratedFile;
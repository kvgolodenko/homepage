{"version":3,"sources":["../../../src/internal-plugins/query-runner/file-parser.js"],"names":["filePath","fileStr","ast","apiRunnerNode","filename","contents","transpiled","length","item","tmp","babylon","parse","sourceType","plugins","console","info","undefined","error","sourceFilename","e","log","parseToAst","file","text","queries","ExportNamedDeclaration","path","state","traverse","TaggedTemplateExpression","innerPath","gqlAst","getGraphQLTag","definitions","forEach","def","name","value","process","exit","push","findGraphQLTags","fs","require","crypto","Bluebird","readFileAsync","promisify","readFile","cache","FileParser","indexOf","hash","createHash","update","digest","astDefinitions","kind","files","documents","parseFile","doc","set"],"mappings":"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","file":"file-parser.js","sourcesContent":["// @flow\nconst fs = require(`fs`)\nconst crypto = require(`crypto`)\n\n// Traverse is a es6 module...\nimport traverse from \"babel-traverse\"\nconst babylon = require(`babylon`)\nconst Bluebird = require(`bluebird`)\n\nconst apiRunnerNode = require(`../../utils/api-runner-node`)\nconst { getGraphQLTag } = require(`../../utils/babel-plugin-extract-graphql`)\n\nimport type { DocumentNode, DefinitionNode } from \"graphql\"\n\nconst readFileAsync = Bluebird.promisify(fs.readFile)\n\nasync function parseToAst(filePath, fileStr) {\n  let ast\n\n  // Preprocess and attempt to parse source; return an AST if we can, log an\n  // error if we can't.\n  const transpiled = await apiRunnerNode(`preprocessSource`, {\n    filename: filePath,\n    contents: fileStr,\n  })\n\n  if (transpiled.length) {\n    for (const item of transpiled) {\n      try {\n        const tmp = babylon.parse(item, {\n          sourceType: `module`,\n          plugins: [`*`],\n        })\n        ast = tmp\n        break\n      } catch (e) {\n        console.info(e)\n        continue\n      }\n    }\n    if (ast === undefined) {\n      console.error(`Failed to parse preprocessed file ${filePath}`)\n    }\n  } else {\n    try {\n      ast = babylon.parse(fileStr, {\n        sourceType: `module`,\n        sourceFilename: true,\n        plugins: [`*`],\n      })\n    } catch (e) {\n      console.log(`Failed to parse ${filePath}`)\n      console.log(e)\n    }\n  }\n\n  return ast\n}\n\nasync function findGraphQLTags(file, text): Promise<Array<DefinitionNode>> {\n  let ast = await parseToAst(file, text)\n  if (!ast) return []\n\n  let queries = []\n  traverse(ast, {\n    ExportNamedDeclaration(path, state) {\n      path.traverse({\n        TaggedTemplateExpression(innerPath) {\n          const gqlAst = getGraphQLTag(innerPath)\n          if (gqlAst) {\n            gqlAst.definitions.forEach(def => {\n              if (!def.name || !def.name.value) {\n                console.log(\n                  `\nGraphQL definitions must be \"named\"`\n                )\n\n                console.log(`The query with the missing name is in ${file}`)\n                console.log(\n                  `\nTo fix the query, add \"query MyQueryName\" to the start of your query.\n\nSo instead of:\n\n{\n  allMarkdownRemark {\n    totalCount\n  }\n}\n\nDo:\n\nquery MyQueryName {\n  allMarkdownRemark {\n    totalCount\n  }\n}\n              `\n                )\n                console.log(``)\n                process.exit(1)\n              }\n            })\n\n            queries.push(...gqlAst.definitions)\n          }\n        },\n      })\n    },\n  })\n  return queries\n}\n\nconst cache = {}\n\nexport default class FileParser {\n  async parseFile(file: string): Promise<?DocumentNode> {\n    const text = await readFileAsync(file, `utf8`)\n\n    if (text.indexOf(`graphql`) === -1) return\n    const hash = crypto\n      .createHash(`md5`)\n      .update(file)\n      .update(text)\n      .digest(`hex`)\n\n    let astDefinitions =\n      cache[hash] || (cache[hash] = await findGraphQLTags(file, text))\n\n    return astDefinitions.length\n      ? {\n          kind: `Document`,\n          definitions: astDefinitions,\n        }\n      : null\n  }\n\n  async parseFiles(files: Array<string>): Promise<Map<string, DocumentNode>> {\n    const documents = new Map()\n    for (let file of files) {\n      const doc = await this.parseFile(file)\n\n      if (doc) documents.set(file, doc)\n    }\n\n    return documents\n  }\n}\n"]}
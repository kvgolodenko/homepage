{"version":3,"sources":["../../../src/internal-plugins/query-runner/query-compiler.js"],"names":["compile","normalize","require","_","printTransforms","globp","promisify","ArgumentsOfCorrectTypeRule","DefaultValuesOfCorrectTypeRule","FragmentsOnCompositeTypesRule","KnownTypeNamesRule","LoneAnonymousOperationRule","PossibleFragmentSpreadsRule","ScalarLeafsRule","VariablesAreInputTypesRule","VariablesInAllowedPositionRule","Runner","baseDir","schema","parseEverything","nodes","write","files","filter","d","match","map","concat","getState","pages","p","component","uniq","parser","parseFiles","namePathMap","documents","forEach","doc","filePath","push","definitions","def","name","value","set","compilerContext","addAll","convertASTDocuments","printContext","reduce","ctx","transform","compiledNodes","node","kind","get","has","text","getRoot","print","join","path","program","runner","directory","compileAll"],"mappings":"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","file":"query-compiler.js","sourcesContent":["// @flow\nimport path from \"path\"\nconst normalize = require(`normalize-path`)\nimport glob from \"glob\"\nimport Bluebird from \"bluebird\"\nimport invariant from \"invariant\"\nimport { IRTransforms } from \"relay-compiler\"\nimport ASTConvert from \"relay-compiler/lib/ASTConvert\"\nimport RelayCompilerContext from \"relay-compiler/lib/RelayCompilerContext\"\nimport filterContextForNode from \"relay-compiler/lib/filterContextForNode\"\nconst _ = require(`lodash`)\n\nimport { store } from \"../../redux\"\nimport FileParser from \"./file-parser\"\nimport QueryPrinter from \"./query-printer\"\n\nimport type { DocumentNode, GraphQLSchema } from \"graphql\"\n\nconst { printTransforms } = IRTransforms\nconst globp = Bluebird.promisify(glob)\n\nconst {\n  ArgumentsOfCorrectTypeRule,\n  DefaultValuesOfCorrectTypeRule,\n  FragmentsOnCompositeTypesRule,\n  KnownTypeNamesRule,\n  LoneAnonymousOperationRule,\n  PossibleFragmentSpreadsRule,\n  ScalarLeafsRule,\n  VariablesAreInputTypesRule,\n  VariablesInAllowedPositionRule,\n} = require(`graphql`)\n\ntype RootQuery = {\n  name: string,\n  path: string,\n  text: string,\n}\n\nclass Runner {\n  baseDir: string\n  schema: GraphQLSchema\n\n  constructor(baseDir: string, schema: GraphQLSchema) {\n    this.baseDir = baseDir\n    this.schema = schema\n  }\n\n  async compileAll() {\n    let nodes = await this.parseEverything()\n    return this.write(nodes)\n  }\n\n  async parseEverything() {\n    let files = await globp(`${this.baseDir}/**/*.+(t|j)s?(x)`)\n    files = files.filter(d => !d.match(/\\.d\\.ts$/))\n    files = files.map(normalize)\n    // Ensure all page components added as they're not necessarily in the\n    // pages directory e.g. a plugin could add a page component.  Plugins\n    // *should* copy their components (if they add a query) to .cache so that\n    // our babel plugin to remove the query on building is active (we don't\n    // run babel on code in node_modules). Otherwise the component will throw\n    // an error in the browser of \"graphql is not defined\".\n    files = files.concat(\n      store.getState().pages.map(p => normalize(p.component))\n    )\n    files = _.uniq(files)\n\n    let parser = new FileParser()\n\n    return await parser.parseFiles(files)\n  }\n\n  async write(nodes: Map<string, DocumentNode>) {\n    const namePathMap = new Map()\n    const documents = []\n\n    nodes.forEach((doc, filePath) => {\n      documents.push(doc)\n      doc.definitions.forEach((def: any) => {\n        const name: string = def.name.value\n        namePathMap.set(name, filePath)\n      })\n    })\n\n    let compilerContext = new RelayCompilerContext(this.schema)\n    compilerContext = compilerContext.addAll(\n      ASTConvert.convertASTDocuments(this.schema, documents, [\n        ArgumentsOfCorrectTypeRule,\n        DefaultValuesOfCorrectTypeRule,\n        FragmentsOnCompositeTypesRule,\n        KnownTypeNamesRule,\n        LoneAnonymousOperationRule,\n        PossibleFragmentSpreadsRule,\n        ScalarLeafsRule,\n        VariablesAreInputTypesRule,\n        VariablesInAllowedPositionRule,\n      ])\n    )\n\n    const printContext = printTransforms.reduce(\n      (ctx, transform) => transform(ctx, this.schema),\n      compilerContext\n    )\n\n    const compiledNodes: Map<string, RootQuery> = new Map()\n\n    compilerContext.documents().forEach((node: { name: string }) => {\n      if (node.kind !== `Root`) return\n\n      const { name } = node\n      let filePath = namePathMap.get(name) || ``\n\n      invariant(\n        !compiledNodes.has(filePath),\n        `Gatsby: Pages may only specify one \"root\" query tag. ` +\n          `Combine them into a single query`\n      )\n\n      let text = filterContextForNode(printContext.getRoot(name), printContext)\n        .documents()\n        .map(QueryPrinter.print)\n        .join(`\\n`)\n\n      compiledNodes.set(filePath, {\n        name,\n        text,\n        path: path.join(this.baseDir, filePath),\n      })\n    })\n\n    return compiledNodes\n  }\n}\n\nexport default function compile(): Promise<Map<string, RootQuery>> {\n  const { program, schema } = store.getState()\n\n  const runner = new Runner(`${program.directory}/src`, schema)\n\n  return runner.compileAll()\n}\n"]}